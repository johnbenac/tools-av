#!/usr/bin/env python3
"""
av-cleaver - Split audio from video, or merge them back together
"""

import argparse
import os
import subprocess
import sys
import tempfile
from pathlib import Path

VERSION = "1.0.0"

class AVCleaverError(Exception):
    """Base exception for av-cleaver errors"""
    pass

class DurationMismatchError(AVCleaverError):
    """Duration validation failed"""
    pass


def run_command(cmd, verbose=False, dry_run=False):
    """Run a command and return output"""
    if verbose or dry_run:
        print(f"[CMD] {' '.join(cmd)}")

    if dry_run:
        return None

    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            check=True
        )
        return result.stdout.strip()
    except subprocess.CalledProcessError as e:
        raise AVCleaverError(f"Command failed: {' '.join(cmd)}\n{e.stderr}")


def probe_stream_duration(file_path, stream_type='a', verbose=False):
    """Get stream duration using ffprobe"""
    cmd = [
        'ffprobe',
        '-v', 'error',
        '-select_streams', f'{stream_type}:0',
        '-show_entries', 'stream=duration',
        '-of', 'default=noprint_wrappers=1:nokey=1',
        str(file_path)
    ]

    try:
        output = run_command(cmd, verbose=False)
        if output and output != 'N/A':
            duration = float(output)
            # Treat 0.0 as invalid/missing
            if duration > 0.0:
                if verbose:
                    print(f"[INFO] Using {stream_type} stream duration: {duration:.3f}s")
                return duration
    except (ValueError, AVCleaverError):
        pass

    return None


def probe_format_duration(file_path, verbose=False):
    """Get format duration using ffprobe (fallback)"""
    cmd = [
        'ffprobe',
        '-v', 'error',
        '-show_entries', 'format=duration',
        '-of', 'default=noprint_wrappers=1:nokey=1',
        str(file_path)
    ]

    output = run_command(cmd, verbose=False)
    if output and output != 'N/A':
        duration = float(output)
        if verbose:
            print(f"[INFO] Using format duration: {duration:.3f}s")
        return duration

    raise AVCleaverError(f"Could not determine duration for {file_path}")


def get_duration(file_path, stream_type='a', verbose=False):
    """Get duration, trying stream first then format"""
    # Try stream duration first
    duration = probe_stream_duration(file_path, stream_type, verbose)
    if duration is not None:
        return duration

    # Fall back to format duration
    return probe_format_duration(file_path, verbose)


def probe_audio_codec(file_path, verbose=False):
    """Get audio codec name"""
    cmd = [
        'ffprobe',
        '-v', 'error',
        '-select_streams', 'a:0',
        '-show_entries', 'stream=codec_name',
        '-of', 'default=noprint_wrappers=1:nokey=1',
        str(file_path)
    ]

    output = run_command(cmd, verbose=False)
    if not output or output == 'N/A':
        raise AVCleaverError(f"No audio stream found in {file_path}")

    return output


def get_codec_extension(codec, verbose=False):
    """Map codec to preferred file extension"""
    codec_map = {
        'aac': 'm4a',
        'mp3': 'mp3',
        'flac': 'flac',
        'opus': 'opus',
        'vorbis': 'ogg',
        'ac3': 'ac3',
        'eac3': 'ac3',
        'dts': 'dts',
        'truehd': 'thd',
        'pcm_s16le': 'wav',
        'pcm_s24le': 'wav',
        'pcm_s32le': 'wav',
    }

    if codec in codec_map:
        return codec_map[codec]

    # Unknown codec - use MKA (Matroska Audio) as it accepts nearly everything
    if verbose:
        print(f"[INFO] Unknown codec '{codec}' - using .mka container (universal)")
    return 'mka'


def get_format_codec(format_name):
    """Map format name to ffmpeg codec"""
    format_map = {
        'mp3': 'libmp3lame',
        'aac': 'aac',
        'flac': 'flac',
        'wav': 'pcm_s16le',
        'ogg': 'libvorbis',
        'opus': 'libopus',
    }
    return format_map.get(format_name.lower())


def format_matches_codec(format_name, codec_name):
    """Check if a format matches the source codec (for copy vs re-encode)"""
    format_lower = format_name.lower()
    codec_lower = codec_name.lower()

    # Direct matches (format name == codec name)
    if format_lower == codec_lower:
        return True

    # Special mappings for format/codec mismatches
    format_codec_map = {
        'ogg': ['vorbis'],
        'opus': ['opus'],
        'mp3': ['mp3'],
        'aac': ['aac'],
        'flac': ['flac'],
        'wav': ['pcm_s16le', 'pcm_s24le', 'pcm_s32le'],
    }

    if format_lower in format_codec_map:
        return codec_lower in format_codec_map[format_lower]

    # Fallback to substring matching for other cases
    return format_lower in codec_lower or codec_lower in format_lower


def map_video_codec_name(codec_name):
    """Map user-friendly video codec names to ffmpeg encoder names"""
    codec_map = {
        'h264': 'libx264',
        'h265': 'libx265',
        'vp9': 'libvpx-vp9',
        'copy': 'copy',
    }
    return codec_map.get(codec_name, codec_name)


def choose_audio_codec_for_merge(audio_file, output_container, verbose=False):
    """Determine audio codec for merge operation"""
    source_codec = probe_audio_codec(audio_file, verbose)
    container_ext = output_container.lower().lstrip('.')

    # MKV accepts everything
    if container_ext == 'mkv':
        if verbose:
            print(f"[INFO] Copying audio (MKV accepts {source_codec})")
        return 'copy'

    # WebM needs Opus or Vorbis
    if container_ext == 'webm':
        if source_codec in ['opus', 'vorbis']:
            if verbose:
                print(f"[INFO] Copying audio ({source_codec} compatible with WebM)")
            return 'copy'
        else:
            print(f"[INFO] Transcoding {source_codec} to Opus for WebM compatibility")
            return 'libopus'

    # MP4/MOV prefer AAC, MP3, AC3
    if container_ext in ['mp4', 'mov', 'm4v']:
        if source_codec in ['aac', 'mp3', 'ac3', 'eac3']:
            if verbose:
                print(f"[INFO] Copying audio ({source_codec} compatible with MP4)")
            return 'copy'
        else:
            print(f"[INFO] Transcoding {source_codec} to AAC for MP4 compatibility")
            return 'aac'

    # AVI prefers MP3, AC3
    if container_ext == 'avi':
        if source_codec in ['mp3', 'ac3', 'eac3']:
            if verbose:
                print(f"[INFO] Copying audio ({source_codec} compatible with AVI)")
            return 'copy'
        else:
            print(f"[INFO] Transcoding {source_codec} to MP3 for AVI compatibility")
            return 'libmp3lame'

    # Default: try to copy
    if verbose:
        print(f"[INFO] Copying audio (assuming {source_codec} is compatible)")
    return 'copy'


def validate_file_exists(file_path):
    """Check if file exists and is readable"""
    path = Path(file_path)
    if not path.exists():
        raise AVCleaverError(f"File not found: {file_path}")
    if not path.is_file():
        raise AVCleaverError(f"Not a file: {file_path}")
    if not os.access(path, os.R_OK):
        raise AVCleaverError(f"File not readable: {file_path}")


def split_audio(args):
    """Extract audio from video file"""
    validate_file_exists(args.video_file)

    video_path = Path(args.video_file)
    source_codec = probe_audio_codec(args.video_file, args.verbose)

    # Determine output file and codec
    if args.output:
        output_path = Path(args.output)
    else:
        # Auto-generate output name
        if args.format:
            ext = args.format
        else:
            ext = get_codec_extension(source_codec, args.verbose)
        output_path = video_path.parent / f"{video_path.stem}_audio.{ext}"

    # Safety check: never overwrite input files
    if output_path.resolve() == video_path.resolve():
        raise AVCleaverError(
            f"Output path cannot be the same as input file: {output_path}\n"
            f"This would destroy your source video."
        )

    # Check for overwrite
    if output_path.exists() and not args.force:
        raise AVCleaverError(f"Output file exists: {output_path}\nUse --force to overwrite")

    # Determine if we need to re-encode
    need_reencode = args.re_encode
    audio_codec = 'copy'
    bitrate_args = []

    if args.format:
        target_codec = get_format_codec(args.format)
        if not target_codec:
            raise AVCleaverError(f"Unknown format: {args.format}")

        # Check if format matches source codec
        if not format_matches_codec(args.format, source_codec) or args.re_encode:
            need_reencode = True
            audio_codec = target_codec
            if args.verbose:
                print(f"[INFO] Re-encoding {source_codec} to {args.format}")
        else:
            if args.verbose:
                print(f"[INFO] Copying audio (format matches source codec)")
    else:
        if args.verbose:
            print(f"[INFO] Copying audio as-is ({source_codec})")

    # Add bitrate if re-encoding
    if need_reencode and args.bitrate:
        bitrate_args = ['-b:a', args.bitrate]
    elif need_reencode and audio_codec not in ['copy', 'flac', 'pcm_s16le']:
        bitrate_args = ['-b:a', '192k']  # Default bitrate

    # For atomic writes, use temp file in same directory
    if not args.dry_run:
        # Create temp file in same directory as output (for atomic rename)
        temp_fd, temp_path = tempfile.mkstemp(
            suffix=output_path.suffix,
            dir=output_path.parent,
            prefix='.av-cleaver-tmp-'
        )
        os.close(temp_fd)  # Close fd, ffmpeg will open it
        temp_path = Path(temp_path)
        # Set readable permissions (mkstemp defaults to 0600)
        os.chmod(temp_path, 0o644)
        target_path = temp_path
    else:
        target_path = output_path

    # Build ffmpeg command
    cmd = [
        'ffmpeg',
        '-i', str(args.video_file),
        '-vn',  # No video
        '-acodec', audio_codec,
        '-map', '0:a:0',  # First audio stream
    ]

    if bitrate_args:
        cmd.extend(bitrate_args)

    cmd.extend(['-y', str(target_path)])

    # Execute
    try:
        run_command(cmd, verbose=args.verbose, dry_run=args.dry_run)

        if not args.dry_run:
            # Atomic rename on success
            temp_path.rename(output_path)
            print(f"✓ Audio extracted to: {output_path}")
    except:
        # Clean up temp file on failure
        if not args.dry_run and temp_path.exists():
            temp_path.unlink()
        raise


def merge_audio_video(args):
    """Merge audio and video files"""
    validate_file_exists(args.video_file)
    validate_file_exists(args.audio_file)

    video_path = Path(args.video_file)
    audio_path = Path(args.audio_file)

    # Determine output file
    if args.output:
        output_path = Path(args.output)
    else:
        output_path = video_path.parent / f"{video_path.stem}_merged{video_path.suffix}"

    # Safety check: never overwrite input files
    output_resolved = output_path.resolve()
    if output_resolved == video_path.resolve():
        raise AVCleaverError(
            f"Output path cannot be the same as video input: {output_path}\n"
            f"This would destroy your source video."
        )
    if output_resolved == audio_path.resolve():
        raise AVCleaverError(
            f"Output path cannot be the same as audio input: {output_path}\n"
            f"This would destroy your source audio."
        )

    # Check for overwrite
    if output_path.exists() and not args.force:
        raise AVCleaverError(f"Output file exists: {output_path}\nUse --force to overwrite")

    # Duration validation - ALWAYS ENFORCED
    video_dur = get_duration(args.video_file, stream_type='v', verbose=args.verbose)
    audio_dur = get_duration(args.audio_file, stream_type='a', verbose=args.verbose)
    diff = abs(video_dur - audio_dur)

    if diff > args.tolerance:
        raise DurationMismatchError(
            f"Duration mismatch: video={video_dur:.2f}s, audio={audio_dur:.2f}s (diff={diff:.2f}s)\n"
            f"Exceeds tolerance of {args.tolerance}s\n"
            f"Fix the source files - duration mismatch indicates a problem upstream."
        )

    if args.verbose and diff > 0:
        print(f"[INFO] Duration check passed: diff={diff:.3f}s within tolerance {args.tolerance}s")

    # Determine audio codec
    output_ext = output_path.suffix.lstrip('.')
    audio_codec = choose_audio_codec_for_merge(args.audio_file, output_ext, args.verbose)

    # Determine video codec
    video_codec_input = args.video_codec if args.video_codec else 'copy'
    video_codec = map_video_codec_name(video_codec_input)
    if args.verbose:
        if video_codec == 'copy':
            print(f"[INFO] Copying video (no re-encode)")
        else:
            print(f"[INFO] Re-encoding video with {video_codec}")

    # Build bitrate args if transcoding audio
    bitrate_args = []
    if audio_codec != 'copy' and audio_codec not in ['flac', 'pcm_s16le']:
        bitrate_args = ['-b:a', '192k']

    # For atomic writes, use temp file in same directory
    if not args.dry_run:
        # Create temp file in same directory as output (for atomic rename)
        temp_fd, temp_path = tempfile.mkstemp(
            suffix=output_path.suffix,
            dir=output_path.parent,
            prefix='.av-cleaver-tmp-'
        )
        os.close(temp_fd)  # Close fd, ffmpeg will open it
        temp_path = Path(temp_path)
        # Set readable permissions (mkstemp defaults to 0600)
        os.chmod(temp_path, 0o644)
        target_path = temp_path
    else:
        target_path = output_path

    # Build ffmpeg command
    cmd = [
        'ffmpeg',
        '-i', str(args.video_file),
        '-i', str(args.audio_file),
        '-c:v', video_codec,
        '-c:a', audio_codec,
    ]

    if bitrate_args:
        cmd.extend(bitrate_args)

    cmd.extend([
        '-map', '0:v:0',  # First video stream from first input
        '-map', '1:a:0',  # First audio stream from second input
        '-y',
        str(target_path)
    ])

    # Execute
    try:
        run_command(cmd, verbose=args.verbose, dry_run=args.dry_run)

        if not args.dry_run:
            # Atomic rename on success
            temp_path.rename(output_path)
            print(f"✓ Merged output: {output_path}")
    except:
        # Clean up temp file on failure
        if not args.dry_run and temp_path.exists():
            temp_path.unlink()
        raise


def main():
    parser = argparse.ArgumentParser(
        prog='av-cleaver',
        description='Split audio from video, or merge them back together',
        add_help=False
    )

    parser.add_argument('--version', action='version', version=f'av-cleaver {VERSION}')
    parser.add_argument('-h', '--help', action='store_true', help='Show help message')

    subparsers = parser.add_subparsers(dest='command', help='Command to execute')

    # Split command
    split_parser = subparsers.add_parser(
        'split',
        help='Extract audio from video',
        add_help=False
    )
    split_parser.add_argument('video_file', help='Video file to extract audio from')
    split_parser.add_argument('-o', '--output', help='Output audio filename')
    split_parser.add_argument('-f', '--format',
                             choices=['mp3', 'aac', 'flac', 'wav', 'ogg', 'opus'],
                             help='Output audio format')
    split_parser.add_argument('-b', '--bitrate', help='Audio bitrate (e.g., 192k)')

    split_group = split_parser.add_mutually_exclusive_group()
    split_group.add_argument('-c', '--copy', action='store_true',
                            help='Copy audio codec (default)')
    split_group.add_argument('-r', '--re-encode', action='store_true',
                            help='Force re-encoding')

    split_parser.add_argument('-v', '--verbose', action='store_true',
                             help='Verbose output')
    split_parser.add_argument('--dry-run', action='store_true',
                             help='Show commands without executing')
    split_parser.add_argument('--force', action='store_true',
                             help='Overwrite output file if exists')
    split_parser.add_argument('-h', '--help', action='store_true',
                             help='Show help for split command')

    # Merge command
    merge_parser = subparsers.add_parser(
        'merge',
        help='Combine video and audio',
        add_help=False
    )
    merge_parser.add_argument('video_file', help='Video file')
    merge_parser.add_argument('audio_file', help='Audio file')
    merge_parser.add_argument('-o', '--output', help='Output video filename')
    merge_parser.add_argument('-t', '--tolerance', type=float, default=0.1,
                             help='Duration mismatch tolerance in seconds (default: 0.1)')
    merge_parser.add_argument('-c', '--video-codec',
                             choices=['copy', 'h264', 'h265', 'vp9'],
                             help='Video codec (default: copy)')
    merge_parser.add_argument('-v', '--verbose', action='store_true',
                             help='Verbose output')
    merge_parser.add_argument('--dry-run', action='store_true',
                             help='Show commands without executing')
    merge_parser.add_argument('--force', action='store_true',
                             help='Overwrite output file if exists')
    merge_parser.add_argument('-h', '--help', action='store_true',
                             help='Show help for merge command')

    # Handle help before parsing
    if '-h' in sys.argv or '--help' in sys.argv:
        if 'split' in sys.argv:
            with open('/opt/tools-av/av-cleaver/USAGE.txt', 'r') as f:
                content = f.read()
                start = content.find('$ av-cleaver split --help')
                end = content.find('========================================\n$ av-cleaver merge --help')
                print(content[start:end].replace('========================================\n', '').strip())
            return 0
        elif 'merge' in sys.argv:
            with open('/opt/tools-av/av-cleaver/USAGE.txt', 'r') as f:
                content = f.read()
                start = content.find('$ av-cleaver merge --help')
                print(content[start:].replace('========================================\n', '').strip())
            return 0
        else:
            with open('/opt/tools-av/av-cleaver/USAGE.txt', 'r') as f:
                content = f.read()
                end = content.find('\n========================================\n$ av-cleaver split --help')
                print(content[:end].replace('========================================\n', '').strip())
            return 0

    # Parse args
    args = parser.parse_args()

    # Handle no command
    if not args.command:
        with open('/opt/tools-av/av-cleaver/USAGE.txt', 'r') as f:
            content = f.read()
            end = content.find('\n========================================\n$ av-cleaver split --help')
            print(content[:end].replace('========================================\n', '').strip())
        return 0

    try:
        if args.command == 'split':
            split_audio(args)
        elif args.command == 'merge':
            merge_audio_video(args)
        else:
            parser.print_help()
            return 1

        return 0

    except DurationMismatchError as e:
        print(f"ERROR: {e}", file=sys.stderr)
        return 2
    except AVCleaverError as e:
        print(f"ERROR: {e}", file=sys.stderr)
        return 1
    except KeyboardInterrupt:
        print("\nInterrupted", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"UNEXPECTED ERROR: {e}", file=sys.stderr)
        return 1


if __name__ == '__main__':
    sys.exit(main())
